//! A premade facility that sends over channels notifications of signals and that manages the
//! installing, uninstalling, and internal consuming thread.


pub use state::{FinishError, InstallError, UninstallError};
pub(super) mod state;

pub(super) mod receipts_thread;

pub use signals_channel::{encapsulated::Receiver, SendError, Sender};
mod signals_channel;


use super::__internal::Sealed;
use crate::SignalNumber;
use core::fmt::Debug;
use receipts_thread::DelegatesState;


/// Functions for using a `SignalsChannel` type to manage the signal handling as generated by the
/// [`channel_notify_facility`](crate::channel_notify_facility!) macro.
///
/// The underlying global state that is manipulated (which is per-implementer, i.e. per
/// `SignalsChannel` type) is accessed thru a mutex, and so all these methods might block waiting
/// to acquire it if there is concurrent use of these methods of the same `SignalsChannel` type.
/// Such blocking is only very brief, regardless of the possible states of the state, for almost
/// all the methods, except for `finish` and `finish_with_outside_channel` which wait for the
/// "signals-receipt" thread to finish while holding the mutex which might take somewhat longer,
/// and in the supposed-to-never-occur chance that the thread is permanently stuck then those
/// methods would never return and so never release the mutex.
///
/// This trait is sealed to only be implemented automatically by the `channel_notify_facility`
/// macro.  This trait only exists so that macro can provide these functions.
pub trait SignalsChannel: Sealed + Sized {
    /// Returns whether `Self` is currently in the "installed" state that means our signal
    /// handling is active.
    fn is_installed() -> bool;

    /// Returns whether `Self` is currently in the "dormant" state that means our signal handling
    /// is uninstalled but the "signals-receipt" thread can be reused if our signal handling is
    /// re-installed.
    fn is_dormant() -> bool;

    /// Returns whether `Self` is currently in the "finished" state that means our signal handling
    /// is uninstalled and the "signals-receipt" thread doesn't exist.
    fn is_finished() -> bool;

    /// Install global signal handlers, with notifications sent to a newly-created channel and
    /// where the receiving end of that channel is returned.
    ///
    /// The generic `N` type enables choosing how you want signal numbers to be converted to your
    /// own representation of signal notifications.  You may choose it to be `SignalNumber` to not
    /// have any conversion.  If you have conversion and if you choose to have that fail for any
    /// delivered signal numbers, then notifications of the receipt of those will not be sent and
    /// so those will effectively be ignored.
    ///
    /// This should be preferred over [`Self::install_with_outside_channel`], when you don't need
    /// to supply a preexisting channel, and when a single-consumer channel is acceptable.  This
    /// is safer for doing the uninstalling or finishing operations, because [`Self::uninstall`]
    /// and [`Self::finish`] ensure disconnection of the channel, in contrast to the other methods
    /// that cannot.  The returned `Receiver` cannot be cloned, and so is single-owner, as needed
    /// to ensure disconnection when giving-up ownership.
    ///
    /// If it's desired to do uninstalling or finishing, [`Self::uninstall`] or [`Self::finish`]
    /// must be used (not the other methods that also do that).
    ///
    /// # Errors
    /// If our signal handling is already installed.
    ///
    /// # Panics
    /// - If installing a handler fails.  Only possible if an invalid signal number was given.
    fn install<N>(channel_bound: Option<usize>) -> Result<Receiver<N, Self>, InstallError<()>>
    where
        SignalNumber: TryInto<N>,
        N: Send + 'static;

    /// Install global signal handlers, with notifications sent to the given preexisting `notify`
    /// channel that is outside our control.
    ///
    /// If it's desired to do uninstalling or finishing, [`Self::uninstall_with_outside_channel`]
    /// or [`Self::finish_with_outside_channel`] must be used (not the other methods that also do
    /// that).
    ///
    /// # Errors
    /// Same as [`Self::install`] but `notify` is returned in the error so it can be recovered.
    ///
    /// # Panics
    /// Same as [`Self::install`].
    fn install_with_outside_channel<T: Sender>(notify: T) -> Result<(), InstallError<T>>;

    /// Uninstall global signal handlers (fully, at the OS-process level), if [`Self::install`]
    /// was used to install.
    ///
    /// This requires giving up ownership of the `Receiver` that `Self::install()` returned, which
    /// ensures we drop it to disconnect the channel to ensure the "signals-receipt" thread wakes
    /// to clean-up (in case it's blocked on sending on the channel).  (Only a single instance of
    /// a `Receiver<N, Self>` can possibly exist at any time, because `Self::install()` errors if
    /// called while already installed, and so it's impossible for a mismatched `receiver` to be
    /// given.)
    ///
    /// # Errors
    /// - If our signal handling is already uninstalled.
    /// - If [`Self::install_with_outside_channel`] was used to do the installing.
    ///
    /// # Panics
    /// - If installing the default handling for a signal fails.  Only possible if an invalid
    ///   signal number was given.
    fn uninstall<N>(receiver: Receiver<N, Self>) -> Result<(), UninstallError>;

    /// Uninstall global signal handlers (fully, at the OS-process level), if
    /// [`Self::install_with_outside_channel`] was used to install.
    ///
    /// The user must ensure that all receivers for the other end of the channel are dropped to
    /// disconnect the channel, to ensure that the "signals-receipt" thread wakes to clean-up (in
    /// case it's blocked on sending on the channel).  Such dropping usually occurs naturally when
    /// uninstalling, since the other end is no longer needed then, and may be done after calling
    /// this.  Not doing so might deadlock the "signals-receipt" thread.
    ///
    /// # Errors
    /// - If our signal handling is already uninstalled.
    /// - If [`Self::install`] was used to do the installing.
    ///
    /// # Panics
    /// Same as [`Self::uninstall`].
    fn uninstall_with_outside_channel() -> Result<(), UninstallError>;

    /// Do [`Self::uninstall()`], terminate the internal "signals-receipt" thread, and wait for
    /// that thread to finish.
    ///
    /// This is provided in case it's ever needed to completely clean-up and reset the handling to
    /// be like it hadn't been installed before.  It's unnecessary to use this, just to uninstall
    /// the handling.
    ///
    /// This requires giving up ownership of the `Receiver`, for the same reason as described for
    /// [`Self::uninstall`].
    ///
    /// It's not an error if our signal handling is already uninstalled.
    ///
    /// # Errors
    /// - If our signal handling is already finished.
    /// - If [`Self::install_with_outside_channel`] was used to do the installing.
    ///
    /// # Panics
    /// Same as [`Self::uninstall`].
    fn finish<N>(receiver: Receiver<N, Self>) -> Result<(), FinishError>;

    /// Do [`Self::uninstall_with_outside_channel()`], terminate the internal "signals-receipt"
    /// thread, and wait for that thread to finish.
    ///
    /// This is provided in case it's ever needed to completely clean-up and reset the handling to
    /// be like it hadn't been installed before.  It's unnecessary to use this, just to uninstall
    /// the handling.
    ///
    /// The user must ensure that all receivers for the other end of the channel have **already**
    /// been dropped to disconnect the channel, before calling this, to ensure that the
    /// "signals-receipt" thread wakes to see that it must finish (in case it's blocked on sending
    /// on the channel).  If this is not done, this might deadlock.
    ///
    /// It's not an error if our signal handling is already uninstalled.
    ///
    /// # Errors
    /// - If our signal handling is already finished.
    /// - If [`Self::install`] was used to do the installing.
    ///
    /// # Panics
    /// Same as [`Self::uninstall_with_outside_channel`].
    fn finish_with_outside_channel() -> Result<(), FinishError>;
}


/// Only used internally to simplify needed bounds when generically using `SignalsReceipts` types
/// as defined by the [`premade`](crate::premade!) macro.
#[doc(hidden)]
pub trait SignalsReceipts: super::Premade<Continue = DelegatesState, Break = ()> + Debug {}


/// A premade pattern of statically declaring which signal numbers need to have notifications sent
/// on a channel, with the ability to install, uninstall, finish, and re-install with different
/// channels, with an automatically managed thread dedicated to consuming the receipts of signals
/// and dispatching the processing that sends the notifications on the channel, with premade
/// defaults for the finer details.
///
/// Expands to the definition of a module that defines a type named `SignalsChannel` that
/// `impl`ements the [`SignalsChannel`] trait that is used to manage the signal handling and the
/// notifications channels.
///
/// The name of the module defaults to `channel_notify_facility_premade` when not given.
///
/// (This builds on the [`premade`](crate::premade!) macro.)
#[macro_export]
macro_rules! channel_notify_facility {
    {
        $( $signum:ident $(,)? )+
    } => {
        $crate::channel_notify_facility! {
            mod channel_notify_facility_premade {
                $( $signum ),+
            }
        }
    };

    {
        $visib:vis mod $name:ident {
            $( $signum:ident $(,)? )+
        }
    } => {
        $visib mod $name {
            use $crate::{__internal::{
                             channel_notify_facility::{
                                 DelegatesState, ReceiptsThread, State,
                                 SignalsReceipts as SignalsReceiptsTrait},
                             Sealed},
                         channel_notify_facility::{
                             Receiver, Sender, InstallError, UninstallError, FinishError,
                             SignalsChannel as SignalsChannelTrait},
                         SignalNumber};
            use self::signals_receipts_premade::SignalsReceipts;

            $crate::premade! {
                // Import from our `mod $name`.
                (use super::super::{ReceiptsThread, SignalsChannel, SignalsReceipts};)

                type Continue = super::DelegatesState;
                type Break = ();

                // Declare what the processing of each delegates to.  These are called in this
                // order, for each iteration of the consuming loop, which enables
                // `ReceiptsThread::control` to have control before `ReceiptsThread::handler` is
                // called, as needed for our management.
                {callback} => ReceiptsThread::<SignalsChannel, SignalsReceipts>::control;
                $( $signum => ReceiptsThread::<SignalsChannel, SignalsReceipts>::handler; )+
            }

            impl SignalsReceiptsTrait for SignalsReceipts {}

            /// Use the methods on this to install or uninstall the handling.
            pub(crate) struct SignalsChannel;

            /// State of the currently-installed, or uninstalled, handling.
            static STATE: State<SignalsChannel, SignalsReceipts> = State::new();

            impl Sealed for SignalsChannel {}

            /// Our `SignalsChannel` type represents the ability to manipulate our particular
            /// `STATE` global variable (and only that).
            impl SignalsChannelTrait for SignalsChannel {
                fn is_installed() -> bool { STATE.is_installed() }
                fn is_dormant() -> bool { STATE.is_dormant() }
                fn is_finished() -> bool { STATE.is_finished() }

                fn install<N>(
                    channel_bound: Option<usize>
                ) -> Result<Receiver<N, Self>, InstallError<()>>
                where
                    SignalNumber: TryInto<N>,
                    N: Send + 'static
                {
                    STATE.install(channel_bound)
                }

                fn install_with_outside_channel<T: Sender>(
                    notify: T
                ) -> Result<(), InstallError<T>> {
                    STATE.install_with_outside_channel(notify)
                }

                fn uninstall<N>(receiver: Receiver<N, Self>) -> Result<(), UninstallError> {
                    STATE.uninstall(receiver)
                }

                fn uninstall_with_outside_channel() -> Result<(), UninstallError> {
                    STATE.uninstall_with_outside_channel()
                }

                fn finish<N>(receiver: Receiver<N, Self>) -> Result<(), FinishError> {
                    STATE.finish(receiver)
                }

                fn finish_with_outside_channel() -> Result<(), FinishError> {
                    STATE.finish_with_outside_channel()
                }
            }
        }
    };
}
